for(i in 1:6){
veci<-combn(4,2)[,i]
grp1dat<-data[veci,]
grp2dat<-data[-veci,]
t2[i]=((2*2)/4)* t(colMeans(grp1dat)-colMeans(grp2dat)) %*% solve((var(grp1dat)+var(grp2dat))/2) %*% ((colMeans(grp1dat)-colMeans(grp2dat)))
print(t2[i]/4)}
data = rbind(c(50,5),c(60,4),c(30,7),c(34,8),c(40,6))
veci<-combn(4,2)[,i]
veci
grp1dat<-data[veci,]
grp1dat
t2=((2*2)/4)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+var(data[3:5,]))/2) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+var(data[3:5,]))/2) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2
t2/3
data = rbind(c(50,5),c(30,7),c(60,4),c(34,8),c(40,6))
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+var(data[3:5,]))/2) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2/3
data = rbind(c(50,5),c(34,8),c(60,4),c(30,7),c(40,6))
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+var(data[3:5,]))/2) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2/3
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+var(data[3:5,]))/2) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2/3
data = rbind(c(50,5),c(40,6),c(60,4),c(30,7),c(34,8))
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+var(data[3:5,]))/2) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2/3
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+2*var(data[3:5,]))/3) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2/3
data = rbind(c(50,5),c(60,4),c(30,7),c(34,8),c(40,6))
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+2*var(data[3:5,]))/3) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2/3
x = matrix(20.3, -2.5)
x = matrix(20.3, -2.5, nrow = 2)
x = matrix(20.3, -2.5, nrow = 2)
x = matrix(c(20.3, -2.5), nrow = 1, ncol = 2)
x
y = matrix(c(33.56, -3.67, -3.67, 0.83), byrow = F, nrow = 2, ncol = 2)
y
t(x)
solve(y)
t(x)%*%solve(y)%*%x
t(x) %*% solve(y) %*% x
x = matrix(c(20.3, -2.5), nrow = 1, ncol = 2)
y = matrix(c(33.56, -3.67, -3.67, 0.83), byrow = F, nrow = 2, ncol = 2)
t(x) %*% solve(y) %*% x
t(x)
x
solve(y
solve(y)
solve(y)
t(x) %*% solve(y) %*% x
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+2*var(data[3:5,]))/3) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
colMeans(data[1:2,])-colMeans(data[3:5,])
x
t(colMeans(data[1:2,])-colMeans(data[3:5,]))
solve((var(data[1:2,])
solve((var(data[1:2,])+2*var(data[3:5,]))/3)
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*% solve((var(data[1:2,])+2*var(data[3:5,]))/3) %*% ((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2
t2/3
colMeans(data[1:2,])-colMeans(data[3:5,])
t(colMeans(data[1:2,])-colMeans(data[3:5,]))
solve((var(data[1:2,])+2*var(data[3:5,]))/3)
((colMeans(data[1:2,])-colMeans(data[3:5,])))
t(colMeans(data[1:2,])-colMeans(data[3:5,]))
x = matrix(c(20.3, -2.5), nrow = 1, ncol = 2)
x
y = matrix(c(33.56, -3.67, -3.67, 0.83), byrow = F, nrow = 2, ncol = 2)
y
t(x) %*% solve(y) %*% x
x = matrix(c(20.3, -2.5), nrow = 1, ncol = 2)
x = matrix(c(20.3, -2.5), nrow = 1, ncol = 2)
x
t(colMeans(data[1:2,])-colMeans(data[3:5,]))
solve((var(data[1:2,])+2*var(data[3:5,]))/3)
solve(y)
((colMeans(data[1:2,])-colMeans(data[3:5,])))
x
x %*% solve(y) %*% t(x)
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*%
solve((var(data[1:2,])+2*var(data[3:5,]))/3) %*%
((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2
x = matrix(c(20.3, -2.5), nrow = 1, ncol = 2)
y = matrix(c(33.56, -3.67, -3.67, 0.83), byrow = F, nrow = 2, ncol = 2)
x %*% solve(y) %*% t(x)
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*%
solve((var(data[1:2,])+2*var(data[3:5,]))/3) %*%
((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2=((2*3)/5)* t(colMeans(data[1:2,])-colMeans(data[3:5,])) %*%
solve((var(data[1:2,])+2*var(data[3:5,]))/3) %*%
((colMeans(data[1:2,])-colMeans(data[3:5,])))
t2
x = matrix(c(20.3, -2.5), nrow = 1, ncol = 2)
y = matrix(c(33.56, -3.67, -3.67, 0.83), byrow = F, nrow = 2, ncol = 2)
6/5 * x %*% solve(y) %*% t(x)
x
knitr::opts_chunk$set(echo = TRUE)
mytable <- table(iris$Species)
lbls <- paste(names(mytable), "\n", mytable, sep="")
pie(mytable, labels = lbls,
main="Pie Chart of Species\n (with sample sizes)")
df = data.frame(word = c("room","stay","hotel","strip","nice","check","vegas","clean","casino","view"),
percentage = c(0.055, 0.033, 0.032, 0.024, 0.018, 0.017, 0.017, 0.015, 0.014,0.014))
df = data.frame(words = c("room","stay","hotel","strip","nice","check","vegas","clean","casino","view"),
percentage = c(0.055, 0.033, 0.032, 0.024, 0.018, 0.017, 0.017, 0.015, 0.014,0.014))
library(ggplot2)
# Barplot
bp<- ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity")
bp
ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0)
ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) +
scale_fill_brewer(palette="Dark2")
ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) +
scale_fill_brewer(palette="BrBG")
ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) +
scale_fill_brewer(palette="Accent")
ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) +
scale_fill_brewer(palette="Paired")
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, message = FALSE, fig.align='center')
list.of.packages <- c("ggridges", "tidyverse","dplyr","tidyr",
"ggplot2","ggmosaic","productplots","RColorBrewer",
"httr","tigris","leaflet","rgdal")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library(ggridges)
library(tidyverse)
library(dplyr)
library(tidyr)
library(ggplot2)
library(ggmosaic)
library(productplots)
library(RColorBrewer)
library(httr)
library(rgdal)
library(shiny)
w_data = read.csv("business_data_western.csv")
w_data = w_data %>% mutate(cuisine_type = "western")
e_data = read.csv("business_data_eastern.csv")
e_data = e_data %>% mutate(cuisine_type = "eastern")
raw_data = rbind(w_data, e_data)
# colnames(raw_data)
df = raw_data %>%
select(coordinates,cuisine, cuisine_type, id, name, price, rating, review_count) %>%
filter(price != "££" & price != "") %>%
mutate(price = factor(price, levels = c("$", "$$", "$$$", "$$$$")))  %>%
tidyr::separate(data=.,
col=coordinates,
into=c("latitude", "longitude"),
sep=",",
remove=TRUE)
# Change the format of coordinates
df$latitude <-  as.numeric(gsub("\\{'latitude':","",df$latitude))
df$longitude <- gsub("\\}","",df$longitude)
df$longitude <- as.numeric(gsub("'longitude': ","",df$longitude))
num_cuisine = df %>%
group_by(cuisine) %>%
summarise(norows = length(cuisine))
# Join neighbourhood with my data
r <- GET("http://data.beta.nyc//dataset/0ff93d2d-90ba-457c-9f7e-39e47bf2ac5f/resource/35dd04fb-81b3-479b-a074-a27a37888ce7/download/d085e2f8d0b54d4590b1e7d1f35594c1pediacitiesnycneighborhoods.geojson")
nyc_neighborhoods <- readOGR(content(r,'text'), 'OGRGeoJSON', verbose = F)
points <- data.frame(lat=df$latitude, lng=df$longitude)
points_spdf <- points
coordinates(points_spdf) <- ~lng + lat
proj4string(points_spdf) <- proj4string(nyc_neighborhoods)
matches <- over(points_spdf, nyc_neighborhoods)
points <- cbind(points, matches)
all_data <-
left_join(df, points, by = c("latitude" = "lat", "longitude" = "lng")) %>%
select(latitude,longitude,name,cuisine,price,rating,review_count,neighborhood,borough)
# write.csv(all_data, file = "all_data.csv")
# colnames(all_data)
# nrow(all_data)
# sum(is.na(all_data$borough))
# sum(is.na(all_data$neighborhood))
# mean(df$rating)
df0 = df %>%
group_by(rating) %>%
summarise(norows = length(cuisine)) %>%
mutate(aboveavg = (rating >= 4))
ggplot(df0, aes(x = rating, y = norows, fill = aboveavg)) +
geom_bar(stat = "identity", position = "identity", colour = "black", size = .25)   +
labs(x="Rating", y="Count") +
ggtitle("Distributions of Ratings")  +
theme(plot.title = element_text(face = "bold", hjust = 0.5)) +
scale_fill_manual(name = "Above Average", values = c("steelblue", "#ee615a")) +
coord_flip()
ggplot(df) +
geom_mosaic(aes(x=product(price), fill=rating)) +
labs(x="Price", y="Rating")+
ggtitle("Rating Distribution of Each Price") +
theme(plot.title = element_text(face = "bold", hjust = 0.5),
axis.text.y=element_text(size = 6),
axis.text.x=element_text(size = 8)) +
scale_fill_brewer(palette = "Reds")
ggplot(df,aes(cuisine)) +
geom_bar(aes(fill = as.factor(rating))) +
coord_polar(theta ="x") +
scale_fill_brewer(palette = "Spectral") +
ggtitle("Rating Distribution of Each Cuisine") +
theme(plot.title = element_text(face = "bold", hjust = 0.5),
axis.text.y=element_text(size = 6),
axis.text.x=element_text(size = 8))
ggplot(df,aes(cuisine)) +
geom_bar(aes(fill = as.factor(price))) +
coord_polar(theta ="x") +
scale_fill_brewer(palette = "Reds")
ggplot(df, aes(x=rating, y=review_count, group=rating)) +
geom_boxplot(fill="#ff5c33", outlier.colour = "#ff5c33", alpha = .5) +
labs(x="Rating", y="Review Count") +
ggtitle("Distribution of Review Count by Rating") +
theme(plot.title = element_text(face = "bold", hjust = 0.5)) +
scale_x_continuous(breaks = seq(1,5,.5)) +
scale_y_continuous(breaks = seq(0,10000,1000)) +
geom_hline(aes(yintercept=median(df$review_count)), colour="tomato") +
coord_flip()
df = data.frame(words = c("order","restaurant","meal","dinner","server","experience","steak" ,"menu","make","waiter"),
percentage = c(0.054, 0.045, 0.034, 0.030, 0.029, 0.026, 0.024, 0.022, 0.022,0.019))
library(ggplot2)
# Barplot
ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) +
scale_fill_brewer(palette="Paired")
df = data.frame(words = c("room","stay","hotel","strip","nice","check","vegas","clean","casino","view"),
percentage = c(0.055, 0.033, 0.032, 0.024, 0.018, 0.017, 0.017, 0.015, 0.014,0.014))
library(ggplot2)
# Barplot
ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) +
scale_fill_brewer(palette="Paired") +
ggtitle("Topic 4") +
theme(plot.title = element_text(face = "bold", hjust = 0.5))
df = data.frame(words = c("order","restaurant","meal","dinner","server","experience","steak" ,"menu","make","waiter"),
percentage = c(0.054, 0.045, 0.034, 0.030, 0.029, 0.026, 0.024, 0.022, 0.022,0.019))
library(ggplot2)
# Barplot
ggplot(df, aes(x="", y=percentage, fill=words))+
geom_bar(width = 1, stat = "identity") +
coord_polar("y", start=0) +
scale_fill_brewer(palette="Paired") +
ggtitle("Topic 10") +
theme(plot.title = element_text(face = "bold", hjust = 0.5))
load("/Users/kaiyanzheng/Downloads/netmix/data/MID_dyad_CW.RData")
load("/Users/kaiyanzheng/Downloads/netmix/data/MID_monad_CW.RData")
install.packages("tidyverse")
install.packages("tidytext")
install.packages("plotly")
install.packages("DT")
install.packages("tm")
install.packages("wordcloud2")
install.packages("gridExtra")
install.packages("ngram")
load("/Users/kaiyanzheng/Documents/GitHub/fall2019-proj1--Kaiyanzheng/data/lyrics.RData")
load("/Users/kaiyanzheng/Documents/GitHub/fall2019-proj1--Kaiyanzheng/data/lyrics.RData")
View(dt_lyrics)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("~/Desktop/ADA/hw4")
#install.packages("corrplot")
#install.packages("plotly")
library(MASS)
data(Boston)
lm.fit <-  lm(medv ~ crim + zn + indus + nox + rm + age + tax, data = Boston)
summary(lm.fit)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("~/Desktop/ADA/hw4")
#install.packages("corrplot")
#install.packages("plotly")
library(MASS)
data(Boston)
lm.fit <-  lm(medv ~ crim + zn + indus + nox + rm + age + tax, data = Boston)
summary(lm.fit)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
setwd("~/Desktop/ADA/hw4")
library(MASS)
data(Boston)
lm.fit <-  lm(medv ~ crim + zn + indus + nox + rm + age + tax, data = Boston)
library(MASS)
data(Boston)
lm.fit <-  lm(medv ~ crim + zn + indus + nox + rm + age + tax, data = Boston)
vif(lm.fit)
library(MASS)
library(car)
install.packages("car")
#install.packages("car")
library(MASS)
library(car)
install.packages("car")
library(MASS)
library(car)
data(Boston)
lm.fit <-  lm(medv ~ crim + zn + indus + nox + rm + age + tax, data = Boston)
vif(lm.fit)
#install.packages("car")
library(MASS)
library(car)
data(Boston)
lm.fit <-  lm(medv ~ crim + zn + indus + nox + rm + age + tax, data = Boston)
vif(lm.fit)
library(pls)
install.packages("pls")
library(pls)
# Usual linear regression
summary(fit1)
#install.packages("pls")
library(pls)
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~., data = Boston, scale = TRUE, validation = "CV")
summary(pcr.fit)
#install.packages("pls")
library(pls)
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~., data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
library("glmnet")
install.packages("glmnet")
install.packages("mvtnorm")
library(glmnet)
library(mvtnorm)
# lasso
# Find the best lambda using cross-validation
set.seed(1)
cv.lasso <- cv.glmnet(x, Y, alpha = 1)
#install.packages("glmnet")
#install.packages("mvtnorm")
library(glmnet)
library(mvtnorm)
Y <- Boston$medv
x1 <- Boston$crim
x2 <- Boston$zn
x3 <- Boston$indus
x4 <- Boston$nox
x5 <- Boston$rm
x6 <- Boston$age
x7 <- Boston$tax
x <- cbind(x1,x2,x3,x4,x5,x6,x7)
# lasso
# Find the best lambda using cross-validation
set.seed(99)
cv.lasso <- cv.glmnet(x, Y, alpha = 1)
# Fit the final model
model <- glmnet(x, Y, alpha = 1, lambda = cv.lasso$lambda.min)
coef(model)
x.test <- model.matrix(Y ~x)[,-1]
predicted.medv <- predict(model, newx = x.test)
# Model accuracy
mean((predicted.medv-Y)^2)
# stepwise
step.model <- stepAIC(fit1, direction = "both", trace = FALSE)
#install.packages("glmnet")
#install.packages("mvtnorm")
library(glmnet)
library(mvtnorm)
Y <- Boston$medv
x1 <- Boston$crim
x2 <- Boston$zn
x3 <- Boston$indus
x4 <- Boston$nox
x5 <- Boston$rm
x6 <- Boston$age
x7 <- Boston$tax
x <- cbind(x1,x2,x3,x4,x5,x6,x7)
# lasso
# Find the best lambda using cross-validation
set.seed(99)
cv.lasso <- cv.glmnet(x, Y, alpha = 1)
# Fit the final model
model <- glmnet(x, Y, alpha = 1, lambda = cv.lasso$lambda.min)
coef(model)
x.test <- model.matrix(Y ~x)[,-1]
predicted.medv <- predict(model, newx = x.test)
# Model accuracy
mean((predicted.medv-Y)^2)
# stepwise
step.model <- stepAIC(lm.fit, direction = "both", trace = FALSE)
summary(step.model)
predicted.medv <- predict(step.model, newx = x.test)
# Model accuracy
mean((predicted.medv-Y)^2)
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~., data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~., data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
validationplot(pc.fit, val.type = 'R2')
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~., data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
validationplot(pc.fit, val.type = 'R2')
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~crim + zn + indus + nox + rm + age + tax, data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
validationplot(pc.fit, val.type = 'R2')
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~crim + zn + indus + nox + rm + age + tax, data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
validationplot(pc.fit, val.type = 'R2')
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~crim + zn + indus + nox + rm + age + tax, data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
validationplot(pc.fit, val.type = 'R1')
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~crim + zn + indus + nox + rm + age + tax, data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
validationplot(pc.fit, val.type = 'R2')
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
# Priciple Component Regression
pc.fit <- pcr(medv~crim + zn + indus + nox + rm + age + tax, data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
validationplot(pc.fit, val.type = 'R2')
#install.packages("pls")
library(pls)
# usual linear regression
summary(lm.fit)
plot(lm.fit$residuals)
# Priciple Component Regression
pc.fit <- pcr(medv~crim + zn + indus + nox + rm + age + tax, data = Boston, scale = TRUE, validation = "CV")
summary(pc.fit)
plot(pc.fit$residuals)
validationplot(pc.fit, val.type = 'R2')
#install.packages("glmnet")
#install.packages("mvtnorm")
library(glmnet)
library(mvtnorm)
Y <- Boston$medv
x <- cbind(Boston$crim,Boston$zn,Boston$indus,Boston$nox,Boston$rm,Boston$age,Boston$tax)
# lasso
# Find the best lambda using cross-validation
set.seed(99)
cv.lasso <- cv.glmnet(x, Y, alpha = 1)
# Fit the final model
model <- glmnet(x, Y, alpha = 1, lambda = cv.lasso$lambda.min)
coef(model)
x.test <- model.matrix(Y ~x)[,-1]
predicted.medv <- predict(model, newx = x.test)
# Model accuracy
mean((predicted.medv-Y)^2)
# stepwise
step.model <- stepAIC(lm.fit, direction = "both", trace = FALSE)
summary(step.model)
predicted.medv <- predict(step.model, newx = x.test)
# Model accuracy
mean((predicted.medv-Y)^2)
#install.packages("glmnet")
#install.packages("mvtnorm")
library(glmnet)
library(mvtnorm)
Y <- Boston$medv
x <- cbind(Boston$crim,Boston$zn,Boston$indus,Boston$nox,Boston$rm,Boston$age,Boston$tax)
# lasso
set.seed(99)
cv.lasso <- cv.glmnet(x, Y, alpha = 1)
model <- glmnet(x, Y, alpha = 1, lambda = cv.lasso$lambda.min)
coef(model)
x.test <- model.matrix(Y ~x)[,-1]
predicted.medv <- predict(model, newx = x.test)
mean((predicted.medv-Y)^2)
# stepwise
step.model <- stepAIC(lm.fit, direction = "both", trace = FALSE)
summary(step.model)
predicted.medv <- predict(step.model, newx = x.test)
mean((predicted.medv-Y)^2)
options(shiny.sanitize.errors = FALSE)
library(shiny)
setwd("~/Documents/GitHub/fall2019-proj2--sec1-grp1/app")
